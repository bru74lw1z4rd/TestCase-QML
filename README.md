# TestCase-QML

## Техническое задание:
- Считывание и вывод топ 15 слов (по количеству вхождений) в режиме реального времени - ✅
- Приложение должно быть многопоточным - чтение и обработка файла должны происходить в отдельном от UI потоке - ✅
- Интерфейс приложения должен быть адаптивным и учитывать размеры текущего окна - ✅
- Гистограмма должна обновляться в условно реальном времени - ✅
- Гистограмма без использования модуля ChartView - ✅
- Прогресс бар обработки открытого файла - ✅
- Кнопка "Открыть" для выбора файла, из которого будут считаны слова - ✅
- Кнопка "Старт", для запуска чтения файла и подсчета статистики слов - ✅
- Кнопка "Пауза", для приостановки чтения файла - ✅
- Кнопка "Отмена", для прерывания чтения файла и сброса статистики - ✅
- readme файла с описанием архитектуры и логики работы приложения - ✅

## Требования для запуска
**Qt** - 6.6.2

**Tested platforms** - Arch Linux, Android 13

## Демо

**Linux:**

https://github.com/bru74lw1z4rd/TestCase-QML/assets/66485293/41c8bee1-8e2d-44cf-9181-030eabc3ad61

https://github.com/bru74lw1z4rd/TestCase-QML/assets/66485293/b84106d7-3c93-4ff4-846a-5d024a35a426

https://github.com/bru74lw1z4rd/TestCase-QML/assets/66485293/7e8c015a-d537-44b9-b60b-09dd0b7c9b41

https://github.com/bru74lw1z4rd/TestCase-QML/assets/66485293/11bb9bad-4039-44cc-849c-5b49f60ec8ce

https://github.com/bru74lw1z4rd/TestCase-QML/assets/66485293/2cdf1239-1fef-4680-a6f8-f1849ce0dbbb

**Android:**

https://github.com/bru74lw1z4rd/TestCase-QML/assets/66485293/934ad582-ef9a-4b09-94a8-20fbf9605cb1

## Логика работы приложения 

### Описание реализации поиска слов:
1. При запросе обработки файла, требуется изначально проверить и подготовить файл/нужные для него данные, для данных целей используем функцию `prepareFile`;
2. После подготовки, мы ожидаем сигнала, о начале работы, как только сигнал поступает (вызов функции `startWork()`), мы устанавливаем флаг с помощью сеттера `setRunning` означающий, что на данный момент идет работа;
3. Далее запускаем новый поток с помощью `QtConcurrent::run` и открываем файл, который будет считывать;
4. Находим все возможные, подходящие под критерии слова с помощью `QRegularExpression` вместо линейного считывания файла построчно;
5. С помощью итераторов проходим каждый match и заносим в `QHash` *(слово/кол-во использований)*; 
  1. Так же, т.к. мы не можем сортировать `QHash` по значению, создаем `QList`, который будет хранить отсортированные по value значения.
6. С помощью функции `std::find_if` находим, существует ли значение в `QList`, если существует, обновляем значение, если нет, создаем новое. Это немного замедляет процесс выполнения, но нужно для динамического обновления интерфейса;
7. Выполняем контрольную сортировку элементов;
8. Обновляем UI пользователя;
9. Обновляем флаг с помощью сеттера `setRunning`.

### Реализация паузы и отмены (потоки):
Т.к. ед. потоки в Qt, которые имеют [встроенную поддержку паузы,](https://doc.qt.io/qt-6/threads-technologies.html) остановки и т.п - **Qt Concurrent (Map, Filter, Reduce)**, которые не совсем подходят для текущего решения, требовалось реализовывать свою поддержку для `QtConcurrent::run`.

Данный функционал был реализован с помощью `QMutex` и `QWaitCondition`. При каждой итерации обработки слова, мы проверяем, требуется ли остановить или выключить работу потока, при паузе мы просто входим в `while(true)` и ждем пока `QWaitCondition` разбудит mutex, а при полной остановки работы, мы просто выходим из функции.

### Реализация паузы и отмены (UI):
  - Пауза, отмена и т.п. в UI же были воссозданы с помощью `states`. 

### Реализация прогресс бара:
  - Для реализации прогресс был выбран элемент `ProgressBar`. Подсчет значения `to` производился в функции `prepareFile`, а значения `value`, производился в функции `startWork()`, каждое посчитанное слово плюсуется к значению `Q_PROPERTY(currentProgress)` доступному в QML и там устанавливается значение с помощью сигналов и слотов, что позволяет обновлять интерфейс без задержек.

### Файловое окно:
  - Для реализации файлового диалога, был выбран `FileDialog` из `QtQuick.Dialogs`. Он оттестирован и кроссплатформенный.

### Собственная гистограмма: 
  - Для реализации был выбран элемент `ListView`, т.к. он поддерживает динамическое обновление, в нем есть встроенная поддержка оптимизации и кешировании элементов. Для реализации **баров** был использован элемент `ProgressBar` *(на самом деле, мне самому интересно было посмотреть, получится или нет, но оно клево получилось и я решил оставить :D)*. 

### Оптимизация интерфейса:
Оптимизация кастомного графика:
  - Для быстро и динамического обновления данных в графике, использовались **скелетоны** и замена в них данных, без постоянного создания новых и удаления старых объектов. Это позволило уменьшить нагрузку и внедрить какие никакие анимации для бара.
     
Оптимизация взаимодействия с C++:
  - Для оптимизации взаимодействия с C++, в том числе, чтобы не использовать `QFuture`, которые вызывают остановки в работе, были использованы сигналы и слоты, это позволило асинхронно получать результаты выполнения.
